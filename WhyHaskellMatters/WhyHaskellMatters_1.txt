
Why Haskell matters

なぜHaskellなのか

【出典】
https://wiki.haskell.org/Why_Haskell_matters

------------------------------------------------------------------------------------------------------------------------------------------------


1 What are functional programming languages?

Programming languages such as C/C++/Java/Python are called imperative programming languages because they consist of sequences of actions.
 The programmer quite explicitly tells the computer how to perform a task, step-by-step.
 Functional programming languages work differently.
 Rather than performing actions in a sequence, they evaluate expressions.


1 関数型言語とは何か?

プログラミング言語、C/C++/Java/Python などは命令型言語と呼ばれている、その訳はそれらがアクションの連続から構成されているからである.
 プログラマーはとても明確にコンピューターに伝えます、どのように仕事を行うのかを1行1行で.
 関数型言語は異なった仕事をします.
 アクションの連続を実行するというよりはむしろ、関数型は式を評価します.




1.1 The level of abstraction 

There are two areas that are fundamental to programming a computer - resource management and sequencing.
 Resource management (allocating registers and memory) has been the target of vast abstraction,
 most new languages (imperative as well as functional) have implemented garbage collection to remove resource management from the problem,
 and lets the programmer focus on the algorithm instead of the book-keeping task of allocating memory.
 Sequencing has also undergone some abstraction, although not nearly to the same extent.
 Imperative languages have done so by introducing new keywords and standard libraries.
 For example, most imperative languages have special syntax for constructing several slightly different loops,
 you no longer have to do all the tasks of managing these loops yourself.
 But imperative languages are based upon the notion of sequencing - they can never escape it completely.
 The only way to raise the level of abstraction in the sequencing area for an imperative language is to introduce more keywords or standard functions,
 thus cluttering up the language.
 This close relationship between imperative languages and the task of sequencing commands for the processor to execute means
 that imperative languages can never rise above the task of sequencing,
 and as such can never reach the same level of abstraction that functional programming languages can.

 This makes Haskell a more flexible and easy to use language. Haskell tends to be part of the solution for a problem, not a part of the problem itself. 



1.1 抽象化のレベル

コンピュータープログラミングの基礎となる2つの領域があります - 資源管理と順次処理です.
 資源管理(レジスタやメモリへの配備)の問題は抽象化の余地が多大にあるとされてきました.
 最も新しい部類の言語(命令的で同様に機能的)はガーベージコレクタを使うことによりその課題から資源管理を解決しました,
 そしてプログラマーをアルゴリズムを考えることに注力できるようにさせました,資源配備に煩わされる代わりに.
 順次処理も抽象化の試みの対象とされてきました,しかしながら(資源管理と)同程度ほどはなされていないです.
 命令型言語はそれら(抽象化)を新たなキーワードや標準ライブラリの導入により実施してきました.
 例えば,最近の命令型言語ではいくつかの少しずつ異なる繰り返し処理を構築するための特別な構文があります,
 もはやあなたは繰り返し処理の管理を自身で行う必要はありません.
 しかし命令型言語は順次処理の概念の元に成り立っています - 命令型言語は順次処理の概念から完全には解き放たれないです.
 唯一の方法、抽象化の水準にあげる、順次処理における命令型言語のための、、、とはさらなるキーワードや標準機能の導入になります,
 かようにして言語の煩雑さは増します.
 この命令型言語とプロセッサ実行のための順次処理によるタスクの密接な関係は命令型言語は順次処理から解き放つことができないことを意味しています,
 そして関数型言語には可能な抽象化水準へは届き得ない、そういうものとしてあります.


Haskellにおいて,順次処理は取り除かれています.あなたが唯一気をつけることはプログラムは何をするかということです、どのようにや、いつ行うかではなく.
 このことはHaskellをより柔軟にかつ簡単に扱える言語とします. Haskellはそれらの問題解決の一端となりえるでしょう(なる傾向がある),それ自身が問題の一部となることなく.




 1.2 Functions and side-effects in functional languages

Functions play an important role in functional programming languages.
 Functions are considered to be values just like integers or strings.
 A function can return another function, it can take a function as a parameter, and it can even be constructed by composing functions.
 This offers a stronger "glue" to combine the modules of your program.
 A function that evaluates some expression can take part of the computation as an argument for instance, thus making the function more modular.
 You could also have a function construct another function.
 For instance, you could define a function "differentiate" that will differentiate a given function numerically.
 So if you then have a function "f" you could define "f' = differentiate f", and use it like you would normally in a mathematical context.
 These types of functions are called higher order functions.

Here is a short Haskell example of a function numOf that counts the number of elements in a list that satisfy a certain property.

numOf p xs = length (filter p xs)

We will discuss Haskell syntax later, but what this line says is just "To get the result, filter the list xs by the test p and compute the length of the result".
 Now p is a function that takes an element and returns True or False determining whether the element passes or fails the test.
 So numOf is a higher order function, some of the functionality is passed to it as an argument.
 Notice that filter is also a higher order function, it takes the "test function" as an argument.
 Let's play with this function and define some more specialized functions from it.

numOfEven xs = numOf even xs

Here we define the function numOfEven which counts the number of even elements in a list.
 Note that we do not need to explicitly declare xs as a parameter.
 We could [just as well] write numOfEven = numOf even. A very clear definition indeed. But we'll explicitly [type out] the parameters [for now].

Let's define a function which counts the number of elements that are greater or equal to 5 :

numOfGE5 xs = numOf (>=5) xs

Here the test function is just ">=5" which is [passed to] numOf to give us the functionality we need.

Hopefully you should now see that the modularity of functional programming allows us to define a generic functions where some of the functionality is passed as an argument,
 which we can later use to define shorthands for any specialized functions.
 This small example is somewhat trivial, it wouldn't be too hard to re-write the function definition for all the functions above, but for more complex functions this comes in handy.
 You can, for instance, write only one function for traversing an auto-balancing binary tree and have it take some of the functionality as a parameter (for instance the comparison function).
 This would allow you to traverse the tree for any data type by simply providing the relevant comparison function for your needs.
 Thus you can expend some effort in making sure the general function is correct, and then all the specialized functions will also be correct.
 [Not to mention] you wouldn't have to copy and paste code all over your project.
 This concept is possible in some imperative languages as well.
 In some object oriented languages you often have to provide a "Comparator object" for trees and other standard data structures.
 The difference is that the Haskell way is a lot more intuitive and elegant
 (creating a separate type just for comparing two other types and then passing an object of this type is hardly an elegant way of doing it),
 so it's more likely to be used frequently (and not just in the standard libraries).

A central concept in functional languages is that the result of a function is determined by its input, and only by its input.
 There are no side-effects! This extends to variables as well - variables in Haskell do not vary.
 This may sound strange if you're used to imperative programming (where most of the code consists of changing the "contents" of a variable), but it's really quite natural.
 A variable in Haskell is a name that is bound to some value, rather than an abstraction of some low-level concept of a memory cell like in imperative languages.
 When variables are thought of as short-hands for values (just like they are in mathematics), it makes perfect sense that variable updates are not allowed.
 You wouldn't expect "4 = 5" to be a valid assignment in any language, so it's really quite strange that "x = 4; x = 5" is.
 This is often hard to grasp for programmers who are very used to imperative languages, but it isn't as strange as it first seems.
 So when you start thinking things like "This is too weird, I'm going back to C++!", try to force yourself to continue learning Haskell - you'll be glad you did.

Removing side-effects from the equation allows expressions to be evaluated in any order.
 A function will always return the same result if passed the same input - no exceptions.
 This determinism removes a whole class of bugs found in imperative programs.
 In fact, you could even argue that most bugs in large systems can be traced back to side-effects - if not directly caused by them,
 then caused by a flawed design that relies on side-effects.
 This means that functional programs tend to have far fewer bugs than imperative ones. 




 1.2 関数型言語における関数と副作用

関数は関数型言語においては重要な役割を担います.
 関数は整数や文字列のような値として扱えるようよくよく考えられている.
 関数は別の関数を返すことができる, 引数として関数を受け取ることもできる, そして関数は関数の一部として構成されることもできる.
 このことはあたなのプログラムモジュールを結合するための強力な"にかわ"を提供する.
 式を評価する関数はインスタンスへの引数として計算の一部を取得することができる, かようにして関数のモジュラリティを高めることができる.
 また、関数を他の関数の構成要素とすることもできます.
 例えば, "differentiate"という与えられた関数を数値を元に区別する関数を定義します.
 そして関数"f"があれば"f' = differentiate f"のように通常の数値処理的な文脈のように定義することができます.
 そのようなタイプの関数は高階関数と呼ばれます.

短いHaskellの例としてnumOfというあるいくつかの条件を満たしたリストの要素の数をカウントする関数を示します.

numOf p xs = length (filter p xs)

Haskellの構文については後ほど論じます、これは"得たい結果とは、pでxsのリストをフィルタしその結果のリスト長を求める"ということです.
 p は要素を入力にとり、そして要素がテストを満たすか否かを判断し、その結果をTrueとFalseにより返す関数です.
 numOfはまさしく高階関数です、関数の機能の一部はnumOfに引数として渡されます.
 filterもまた高階関数であることに注意です, これはテスト関数を引数として受け取ります.
 numOf関数で遊び、そしてここからさらに特殊化された関数を定義してみましょう.

numOfEven xs = numOf even xs

numOfEvenというリストの偶数の要素数をカウントする関数を定義するとしましょう.
 注釈としてxsをパラメータとして明確に宣言する必要はありません.
 numOfEven = numOf evenと書いても差し支えありません.とても鮮明でわかりやすい定義です.しかし今のところは明確にパラメータを明記することとしましょう.

5以上の要素の数を数える関数を定義しましょう :

numOfGE5 xs = numOf (>=5) xs

これは単なる"5以上"をnumOfに渡し我々が必要とする機能を提供するテスト関数です.

うまいこといけば関数型言語のモジュール性によっていくつかの機能を受け取る汎用的な関数を定義することが可能となり,
 その後に特殊な関数の短縮形を定義するのにそれ使うことができるでしょう.
 この例は幾分面白みにかけます,上記で紹介した関数を再度書き直すことはそれほど難しくはありません,しかしさらに複雑な関数になれば役立つでしょう.
 例えば,たった一つの関数の定義によりオートバランシング2分木を走査し、複数の機能を引数として受け取るものが書けます(例えば比較関数).
 シンプルに提供された比較関数によって様々なデータ型のツリーに対して走査することが可能となるでしょう.
 それ故に確かな正しい汎用的な関数を作成するための労力に費やせます.そしてそれをもとに特殊化された関数もまた正しいでしょう.
 言うまでもなくあなたのプロジェクトに於いてコピーアンドペーストの必要はなくなるでしょう.
 この概念は他の命令型言語でも可能です.
 オブジェクト指向言語では木構造やその他の標準的なデータ構造に対し"Comparator object"を提供する必要が度々ある.
 異なる点はHaskellに於いてはさらに明確でエレガントであるということです.
 (他の2つのタイプを比較するためだけの別のタイプを作成し、そこにオブジェクトを渡すというのは比較を行うエレガントなやり方とは言いがたいです),
 これは特にもっともらしいので頻繁に使われます(標準ライブラリだけでなく).

数型言語の核となる概念は関数の結果は入力によって決まり、入力によってのみしか決まらないということです.
 副作用は一切ありません!このことは変数に対しても同様に拡張されます - Haskellにおける変数は変化しません.
 このことはあなたが命令型言語に慣れていれば奇妙に思えるかもしれません(コードの構築の大半は変数の"内容"を更新するという),しかしこのことはとても自然なことです.
 Haskellの変数は値を結びつける名前です,命令型言語におけるメモリを低水準概念で抽象化するものということよりはむしろ.
 変数が値の短縮形と考えられる場合(数学におけるような),変数の更新が許可されていないということは合理的です.
 "4 = 5"という式が成り立つプログラミング言語なんてものは普通期待しないでしょう,それならば"x = 4; x = 5"などという式もとても奇妙なものということになります.
 これは度々命令型言語に慣れたプログラマーにとって非常に把握しずらいことですが,初めて見たとしたらそれほど奇妙なことではないです.
 それでも"気持ち悪い、やっぱりC++にしよう!"と考えがよぎってきた時は,Haskellの勉強を継続するよう自分自身に強いよう - そのことはあなたをよくするでしょう.

式から副作用を除去することで式を任意の順で評価することが可能となります.
 同じ入力であれば関数は常に同じ結果を返します.例外はありません.
 この結論は命令型言語で見られるバグの全体を取り除きます.
 実際、大規模なシステムにおけるバグの殆どが副作用に依るものと言えます - たとえそれが直接的な原因ではなくとも,
 副作用に頼った欠陥のある設計により引き起こされます.
 このことは関数型プログラムは命令型プログラムよりもより少ないバグを持つ傾向にあること示しています.


 1.3 Conclusion

Because functional languages are more intuitive and offer more and easier ways to get the job done,
 functional programs tend to be shorter (usually between 2 to 10 times shorter).
 The semantics are most often a lot closer to the problem than an imperative version, which makes it easier to verify that a function is correct.
 Furthermore Haskell doesn't allow side-effects, which leads to fewer bugs.
 Thus Haskell programs are easier to write, more robust, and easier to maintain. 

 1.3 結論

関数型言語はより直感的でより簡単な仕事の実行法を提供するため,
 関数型プログラムは短くなる傾向にあります(だいたい２から１０倍ほど).
 セマンティクスは命令型よりも最も問題に近いため,関数が正しいことの証明をより簡単にすることができます.
 そのうえHaskellはいくらかのバグの起因となる副作用を許可しません.
 故にHaskellプログラムはより簡単に書け、より強固で、より維持しやすくなります.
