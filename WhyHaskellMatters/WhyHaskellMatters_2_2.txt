
Why Haskell matters

なぜHaskellなのか

【出典】
https://wiki.haskell.org/Why_Haskell_matters

------------------------------------------------------------------------------------------------------------------------------------------------


 2.4 Elegance

Another property of Haskell that is very important to the programmer,
 even though it doesn't mean as much in terms of stability or performance,
 is the elegance of Haskell.
 To put it simply: stuff just works like you'd expect it to.

プログラマにとってとても重要なもうひとつのHaskellの特徴は,
 パフォーマンスや安定性のうえではそれほど意味はないのですが,
 Haskellの優雅さにあります.


To highlight the elegance of Haskell
 we shall now take a look at a small example.
              ^^^^^^^^^^^
 We choose QuickSort-inspired filtering sort
 because it's a simple algorithm that is actually useful.
 We will look at two versions - one written in C++,
 an imperative language, and one written in Haskell.
 Both versions use only the functionality
 available to the programmer without importing any extra modules
 (otherwise we could just call "sort" in each language's standard library
 and be done with it!).
 Thus, we use the standard sequence primitives of each language
 (a "list" in Haskell and an "array" in C++).
 Both versions must also be polymorphic
 (which is done "automatically" in Haskell,
 and with templates in C++).
 Both versions must use the same recursive algorithm.


Haskellの優雅さをに着目するために
 小さい例を見てみましょう．

 例はクイックソートに基づいたフィルタリングソートです
 なぜなら実際に有用でシンプルなアルゴリズムだからです.
 2つのバージョンのコードをお見せします - ひとつはC++で書かれた
 命令型言語によるもの,そしてもうひとつはHaskellによるものです.
 両バージョンとも外部モジュールをインポートせずに使用可能な機能のみを使います
 (そうでなければそれぞれの標準ライブラリに搭載されている"sort"関数をコール
 するだけで完了してしまいます!).
 それ故に,各言語における標準的な基本機能のみを使用します
 (Haskellは"リスト"とよばれるものでC++は"配列"を使用します)
 両バージョンともまた多態的にしなければなりません
 (Haskellでは自動的になされています, C++はテンプレートを使用します).
 両バージョンともまたおなじ再帰アルゴリズムを使用しなければなりません.


Please note that this is not intended as a definite comparison
 between the two languages.
 It's intended to show the elegance of Haskell,
 the C++ version is only included for comparison
 (and would be coded quite differently
 if you used the standard QuickSort algorithm or
 the Standard Template Libraries (STL), for example).

注意して欲しいのは2つの言語の比較をすることを意図しているわけでは
 ないということです.
 Haskellのエレガントさに注目して欲しいことを意図しているのであって
 そのためだけの比較としてC++を使っているだけです
 (もし標準的なクイックソートアルゴリズムを使用するか
 STLを使用するのであれば例とはかなり違ったコードとなるでしょう)


-----------------------------------------------------------------------
template <typename T>
void qsort (T *result, T *list, int n)
{
    if (n == 0) return;
    T *smallerList, *largerList;
    smallerList = new T[n];
    largerList = new T[n];
    T pivot = list[0];
    int numSmaller=0, numLarger=0;
    for (int i = 1; i < n; i++)
        if (list[i] < pivot)
            smallerList[numSmaller++] = list[i];
        else
            largerList[numLarger++] = list[i];

    qsort(smallerList,smallerList,numSmaller);
    qsort(largerList,largerList,numLarger);

    int pos = 0;
    for ( int i = 0; i < numSmaller; i++)
        result[pos++] = smallerList[i];

    result[pos++] = pivot;

    for ( int i = 0; i < numLarger; i++)
        result[pos++] = largerList[i];

    delete [] smallerList;
    delete [] largerList;
};
-----------------------------------------------------------------------

We will not explain this code further,
 just note how complex and difficult it is to understand at a glance,
 largely due to the programmer having to deal with low-level details
 which have nothing to do with the task at hand.
 Now, let's take a look at a Haskell version of FilterSort,
 which might look a something like this.


さらにこのコードを説明するつもりはありません,
 どれほど複雑で一瞥して理解することが困難であるかというだけです,
 本質的な処理とは無関係で低レベルな細部の処理が膨大なためです.
 それではHaskellでのフィルターソートを見てみましょう,
 ちょうどこんな感じです.

-----------------------------------------------------------------------
 qsort :: (Ord a) => [a] -> [a]
 qsort []     = []
 qsort (x:xs) = qsort less ++ [x] ++ qsort more
     where less = filter (<x)  xs
           more = filter (>=x) xs
-----------------------------------------------------------------------

(This implementation has very poor runtime and space complexity,
 but that can be improved, at the expense of some of the elegance.)

(この実装はランタイムと空間の使用の複雑さが非常に悪いです,
 しかしいかほどかの優雅さを犠牲にすれば改善は可能です)

Let's dissect this code in detail,
 since it uses quite a lot of Haskell syntax
 that you might not be familiar with.

コードの細部について解剖していきましょう,
 おそらくは馴染みのないHaskell構文がかなり多く使われていることでしょうから.


The first line is a type signature.
 It declares "qsort" to be function
 that takes a list "[a]" as input and returns ("->") another list "[a]".
 "a" is a type variable (vaguely similar to a C++ template declaration),
 and "(Ord a)" is a constraint that means
 that only types that have an ordering are allowed.
 This function is a generic ("template") function,
 that can sort any list of pairwise-comparable objects.
 The phrase "(Ord a) => [a] -> [a]" means "if the type 'a' is ordered,
 than a list of 'a' can be passed in,
 and another list of 'a' will come out. "

最初の行は型宣言です.
 "[a]"というリストを入力にとり、それとは異なるリスト"[a]"を返す関数として
 "qsort"を宣言しています.
 "a" は型変数です(C++で言うところのテンプレートみたいなものです),
 "(Ord a)" は順序付けの可能な型のみが許可されるという事を意味する構成要素です.
 この関数はジェネリクス(テンプレート)な関数であり,
 対での比較ができるオブジェクトのリストに対してソート可能です.
 "(Ord a) => [a] -> [a]"というフレーズは"もし型aが順序性を持っていれば,
 'a'のリストは関数に渡すことができ,そして別の'a'のリストが出力される."
 ということを意味しています.


The function is called qsort and takes a list as a parameter.
 We define a function in Haskell like so: funcname a b c = expr,
 where funcname is the name of the function, a, b, and, c
 are the parameters and expr is the expression to be evaluated
 (most often using the parameters).
 Functions are called by simply putting the function name first
 and then the parameter(s).
 Haskell doesn't use parenthesis for function application.
 Functions simply bind more tightly than anything else,
 so "f 5 * 2", for instance,
 would apply f to 5 and then multiply by 2,
 if we wanted the multiplication to occur before
 the function application then we would use parenthesis like so "f (5*2)".

関数はqsortと呼ばれ,リストをパラメータとしてとります.
 Haskellの関数はこのように定義します: funcname a b c = expr,
 funcname は関数の名前です, a, b, cは引数です,
 exprは評価される式です(ほとんどの場合引数を使います).
 関数は関数名が最初に置かれその後にパラメータが続く簡素な記述により
 呼びだされます.
 Haskellは関数を適用する際に括弧は使用しません.
 関数は他のあらゆるものよりも堅く結びつけられます,
 例えば,"f 5 * 2",とあれば
 fを5に適用してから2を掛けます,
 もし掛け算を関数の適用より先に起こしたい場合は
 "f (5*2)"のように括弧を使用します.

Let's get back to FilterSort.
 First we see that we have two definitions of the functions.
 This is called pattern matching and
 we can briefly say that it will test the argument passed to
 the function top-to-bottom and use the first one that matches.
 The first definition matches against [] which in
 Haskell is the empty list (a list of 1,2 and 3 is [1,2,3]
 so it makes sense that an empty list is just two brackets).
 So when we try to sort an empty list, the result will be an empty list.
 Sounds reasonable enough, doesn't it?
 The second definition pattern matches against a list
 with at least one element.
 It does this by using (x:xs) for its argument.
 The "cons" operator is (:) and it simply puts an element in front of a list,
 so that 0 : [1,2,3] returns [0,1,2,3].
 Pattern matching against (x:xs) is a match against
 the list with the head x and the tail xs
 (which may or may not be the empty list).
 In other words, (x:xs) is a list of at least one element.
 So since we will need to use the head of the list later,
 we can actually extract this very elegantly by using pattern matching.
 You can think of it as naming the contents of the list.
 This can be done on any data construct, not just a list.
 It is possible to pattern match against an arbitrary variable name
 and then use the head function on that to retrieve the head of the list.
 Now if we have a non empty list,
 the sorted list is produced by sorting all elements that are
 smaller than x and putting that in front of x,
 then we sort all elements larger than x and put those at the end.
 We do this by using the list concatenation operator ++.
 Notice that x is not a list so the ++ operator won't work on it alone,
 which is why we make it a singleton-list by putting it inside brackets.
 So the function reads "To sort the list,
 sandwich the head between the sorted list of all elements
 smaller than the head,
 and the sorted list of all elements larger than the head".
 Which could very well be the original algorithm description.
 This is very common in Haskell.
 A function definition usually resembles the informal
 description of the function very closely.
 This is why I say that Haskell has a smaller semantic gap than
 other languages.

フィルターソートに戻りましょう.
 始めに関数の定義が2つあることがわかります.
 これはパターンマッチと呼ばれており
 手短に説明すると関数に渡される引数は上から下へ走査され最初にマッチする関数が
 適用されます.
 最初の定義は[]に対してマッチします,これはHaskellにおける空リストです(1,2,3
 のリストは[1,2,3]です(空リストはちょうど2つの空括弧であることはとても
 理にかなっています).
 空リストに対してソートを試した場合,結果は空リストになるでしょう.
 十分に合理的な感じではないでしょうか?
 2つ目の定義パターンには少なくとも1つの要素のリストにマッチします.
 引数に(x:xs)を使うことによってそれは可能です.
 (:)は"cons"オペレータであり,単純にリストの先頭に要素を加えます,
 例えば 0 : [1,2,3] は[0,1,2,3]を返します.
 (x:xs)に対するパターンマッチは先頭がxで以降がxs(xsは空リストだったり
 そうではなかったりします)のリストに対してマッチします.
 言い換えれば(x:xs)は少なくとも一つの要素を持つリストです.
 後でリストの先頭を使う必要がある際に
 パターンマッチの使用によってとても実際エレガントにそれを取り出すことが可能です.
 リスト内容に名前をつけることも可能です.
 これはリスト以外のあらゆるデータの構成物に対して行うことが可能です.
 任意の変数名に対してパターンマッチを行い,head関数を使用してリストの先頭要素を
 取り出すことも可能です.
 それでは空のリストではないとしましょう,
 ソート済みのリストはxより小さい要素でソートしたものをxの前に置き､
 xより大きい要素でソートしたものをxの後に置くことによって提供されます.
 これはリスト結合オペレータ ++により行います.
 注意して欲しいのはリストではないxだけでは ++ 演算子は使用できないため,
 xをブラケットの中に於いて単一要素のリストとしています.
 つまりは関数はこのように解釈することができます"sortは先頭要素を
 全ての要素のなかで先頭要素より小さい要素のソート済みのリストと全ての要素のなかで
 先頭要素より大きい要素のソート済みのリストで挟むことである"と.
 これはアルゴリズムの記述そのものと言うこともできます.
 これはHaskellにおいては非常に一般的です.
 関数の定義は概ねにおいて関数のおおよその概要に非常に似ています.
 これは私がHaskellは他の言語と比べてより意味的な相違が少ないと言うことの理由です.


But wait, we're not done yet! How is the list less and more computed?
 Well, remember that we don't care about sequencing in Haskell,
 so we've defined them below the function using the where notation
 (which allows any definitions to use the parameters of the function
 to which they belong).
 We use the standard prelude function filter,
 I won't elaborate too much on this now,
 but the line less = filter (<x) xs will use filter (<x) xs to filter
 the list xs.
 You can see that we actually pass the function which will be used
 to filter the list to filter,
 an example of higher order functions.
 The function (<x) should be read out "the function 'less than x'"
 and will return True if an element passed to it is less than x
 (notice how easy it was to construct a function on the fly,
 we put the expression "<x",
 "less than x", in parenthesis and sent it off to
 the function - functions really are just another value!).
 All elements that pass the test are output from the filter function
 and put inside less.
 In a same way (>=x) is used to filter the list for all elements
 larger than or equal to x.

待ってください,まだ終わっていません!
 Haskellにおいてはシーケンシングについては気にしないことを思い出してください,
 その概念を元にそれらを定義します
 (あらゆる定義は関数の引数となることが可能です)
 スタンダードpreludeのfilter関数を使用します,
 現段階ではこれについて詳細に説明はするつもりはありませんが,
 less = filter (<x) xsはリスト xs をフィルタリングします.
 filter関数でリストをフィルタリングするために関数を実際に渡せることがわかる
 でしょう.
 これは高階関数の例です.
 関数 (<x) は"'x より小さい'という関数"であり
 渡された要素が x より小さい場合は真を返します.
 (その場で関数を構築することがいかに簡単か注意してください,
 "<x" と式を書く,
 "x より小さい"という関数を括弧で括り関数に渡します - 
 関数は単に値のひとつに過ぎません!).
 テストに合格した全ての要素はfilter関数の出力となり
 less に紐付けられます.
 同じ方法で (>=x) は x 以上の全ての要素をフィルタリングするために
 使用されます.

Now that you've had the syntax explained to you,
 read the function definition again.
 Notice how little time it takes to get an understanding about
 what the function does.
 The function definitions in Haskell explain what it computes, not how.

これであらかたの構文についての説明を終えました,
 関数定義に戻りましょう.
 関数が何をするかを理解するのにかかる時間がどのように少ないことかに注目
 してください.
 Haskellにおける関数定義は何を評価するかを説明します、どのようにではなく.


If you've already forgotten the syntax outlined above,
 don't worry! We'll go through it more thoroughly and
 at a slower pace in the tutorials.
 The important thing to get from this code example is
 that Haskell code is elegant and intuitive.
 

もし上述の構文を忘れてしまったとしても心配しないで下さい!
 より徹底的にかつゆっくりしたペースでチュートリアルを行います.
 この例文から得られる大切なこととはHaskellコードは
 エレガントかつ直感的ということです.
