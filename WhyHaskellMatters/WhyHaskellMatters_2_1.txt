
Why Haskell matters

なぜHaskellなのか

【出典】
https://wiki.haskell.org/Why_Haskell_matters

------------------------------------------------------------------------------------------------------------------------------------------------

 2 What can Haskell offer the programmer?

Haskell is a modern general purpose language developed to incorporate
 the collective wisdom of the functional programming community
 into one elegant, powerful and general language. 

 2 Haskellがプログラマーに提供するもの

Haskellはひとつのエレガントで強力かつ汎用的な言語を開発するために
 関数型プログラムコミュニティの知識を集約した組織により開発された
 モダンで汎用的な言語です.



 2.1 Purity

Unlike some other functional programming languages Haskell is pure.
 It doesn't allow any side-effects.
 This is probably the most important feature of Haskell.
 We've already briefly discussed the benefits of pure,
 side-effect free,
 programming - and there's not much more we can say about that.
 You'll need to experience it yourself. 


 2.1 純粋性

その他の関数型言語とは違いHaskellは純粋です.
 それは副作用を許容しません.
 これは恐らくHaskellにおける最も重要な特徴でしょう.
 既に純粋性のもたらす利益や,副作用からの開放,プログラミングについて簡単に
 論じました - そしてそれ以上我々がそのことについて説明できることはありません.
 貴方自身でそれを体験する必要があります.



 2.2 Laziness

Another feature of Haskell is that it is lazy
 (technically speaking, it's "non-strict").
 This means that nothing is evaluated until it has to be evaluated.
 You could, for instance,
 define an infinite list of primes without ending up in infinite recursion.
 Only the elements of this list that are actually used will be computed.
 This allows for some very elegant solutions to many problems.
 A typical pattern of solving a problem
 would be to define a list of all possible solutions
 and then filtering away the illegal ones.
 The remaining list will then only contain legal solutions.
 Lazy evaluation makes this operation very clean.
 If you only need one solution you can
 simply extract the first element of the resulting list
 - lazy evaluation will make sure that nothing is needlessly computed. 


 2.2 怠惰性

もうひとつのHaskellの特徴は怠惰だということです
 (技術的にはそれを"非正格"といいます)
 これは評価する必要があるまで何も評価されないことを意味します.
 例えば無限の再帰による終了のない素数の無限リストを定義することができます.
 実際に使われるリストの要素だけが計算されます.
 これによりたくさんの問題に対して多くのとても洗練された解決法が提供されます.
 問題を解決する典型的なパターンは全ての可能な解決策のリストを定義し
 そこから違法なものを取り除くことでしょう.
 残ったリストは適切な解決を含んだものだけでしょう.
 遅延評価はこの作業をとても簡潔にするでしょう.
 ひとつの結果だけが欲しい場合は結果のリストから簡単に最初の要素だけを
 抜き出すことが可能です
 - 遅延評価は不要な計算はされないことを確かとします.



 2.3 Strong typing

Furthermore Haskell is strongly typed, this means just what it sounds like.
 It's impossible to inadvertently convert a Double to an Int,
 or follow a null pointer.
 This also leads to fewer bugs.
 It might be a pain in the neck in the rare cases
 where you need to convert an Int to a Double explicitly
 before performing some operation,
 but in practice this doesn't happen often enough to become a nuisance.
 In fact, forcing each conversion to be explicit often helps
 to highlight problem code.
 In other languages where these conversions are invisible,
 problems often arise when the compiler treats a double like an integer or,
 even worse, an integer like a pointer.

そのうえHaskellは強力な型付けです.
 うっかりDouble型をInt型に変換したり,
 nullポインタを辿ってしまうことを不可能にします.
 これはまたバグを少なくすることに繋がります.
 処理を実行する前にIntをDoubleに明示的に変換する必要があるような
 稀なケースでは困ったことになりますが,
 実際には困りごとになるほどそれはほぼ起きえません.
 実際,強制的に各変換処理を明示することは度々問題のある
 コードを強調表示する助けとなります.
 これらの変換が暗黙的に行われるその他の言語では,
 コンパイラーが倍精度を整数と扱うときや、悪くすると
 整数をポインタとして扱う際によく問題が発生します.



Unlike other strongly typed languages types
 in Haskell are automatically inferred.
 This means that you very rarely have to declare the types of your functions,
 except as a means of code documentation.
 Haskell will look at how you use the variables and
 figure out from there what type the variable should be
 - then it will all be type-checked to ensure there are no type-mismatches.
 Python has the notion of "duck typing",
 meaning "If it walks and talks like a duck, it's a duck!".
 You could argue that Haskell has a much better form of duck typing.
 If a value walks and talks like a duck,
 then it will be considered a duck through type inference,
 but unlike Python the compiler will also catch errors if later on it tries
 to bray like a donkey! So you get the benefits of strong typing
 (bugs are caught at compile-time, rather than run-time)
 without the hassle that comes with it in other languages.
 Furthermore Haskell will always infer the most general type on a variable.
 So if you write, say, a sorting function without a type declaration,
 Haskell will make sure the function will work
 for all values that can be sorted.



その他の強い型付けの言語と違いHaskellの型は
 自動で推定されます.
 コードをドキュメント化したいという目的を除けば、自分が作成した関数の型を
 明示する必要がほとんどないということを表しています.
 Haskellは値がどのように使われるかを見て、
 そこからその値の型が何であるべきかを理解します
 - そして型の不整合がないことを確実にするために型チェックを行います.
 Pythonには"ダックタイピング"と呼ばれる概念があります,
 それは"もし何かがアヒルのように歩き、泣けばそれはアヒルである"という考えです.
 あなたはHaskellはより洗練されたダックタイピングスタイルを
 持つとことを示すことができます.
 値が型推論によりアヒルであると検討されたとしても
 Pythonとは違いコンパイラーはその後にその値がロバのように鳴く事を試みられたと
 判断した場合はエラーをも検出します.
 それ故、あなたは強い型付けの利点を得ることができます
 (バグはランタイムよりもコンパイル時に発見されるため)
 その他の言語に付随する困りごとはなしに.
 その上Haskellは常にその値における最も汎用的な型を推論します.
 したがって、もし型宣言なしに並べ替えを行う関数を定義したのであれば
 Haskellは並べ替え可能な全ての値に対してその関数が機能する事を約束します.

Compare how you would do this in certain object oriented languages.
 To gain polymorphism you would have to use some base class,
 and then declare your variables as instances of subclasses
 to this base class.
 It all amounts to tons of extra work and ridiculously
 complex declarations just to proclaim the existence of a variable.
 Furthermore you would have to perform tons of type conversions
 via explicit casts - definitely not a particularly elegant solution.
 If you want to write a polymorphic function in these object
 oriented languages you would probably declare the parameters
 as an object of a global base class (like "Object" in Java),
 which essentially allows the programmer to send anything into the function,
 even objects which can't logically be passed to the function.
 The end result is that most functions you write
 in these languages are not general, they only work on a single data type.
 You're also moving the error checking from compile-time to run-time.
 In large systems where some of the functionality is rarely used,
 these bugs might never be caught until they cause
 a fatal crash at the worst possible time.

Haskell provides an elegant, concise and safe way to write your programs.
 Programs will not crash unexpectedly, nor produce strangely garbled output.  


特定のオブジェクト指向言語でこれをどのように行うか見比べてみましょう.
 多態性を得るためにいくつかの基本クラスを使用し、
 そのサブクラスのインスタンスとして値を宣言する必要があります.
 変数の存在を宣言するだけで多大な作業と馬鹿げたほど複雑な宣言に
 及びます.
 その上明示的なキャストにより多大な型変換を要する必要があるでしょう.
 - とりわけエレガントな解決策ではないことは明白です.
 これらのオブジェクト指向言語によって多相的な関数を書くとすれば
 おそらくは引数を包括的な基本クラス(Javaで言う"Object"クラスのような)
 によって宣言するでしょう、本質的にプログラマにあらゆる値を関数に渡す事を
 許可し、その上、値は論理的に関数に渡されないような.
 最終的にはこれらの言語で書かれたほとんどの関数は汎用的ではありません、
 これらは単一のデータ型でしか機能しません.
 またエラー確認をコンパイル時にするのではなく実行時にするようにしてしまいます.
 大規模なシステムにおけるごく稀にしか使用されないいくつかの機能においては
 これらのバグは起こりうる最悪のタイミングで致命的なクラッシュを引き起こすまで
 補足されない可能性もあります.

Haskellはエレガントで、簡潔で安全なプログラムを記述する方法をを提供します.
 プログラムは予期しないクラッシュを起こしません、奇妙で要領を得ない出力
 もまた生み出すことはありません.

